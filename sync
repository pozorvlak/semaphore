#!/usr/bin/env python

"""This module is part of Swampy, a suite of programs available from
allendowney.com/swampy.

Copyright 2011 Allen B. Downey
Distributed under the GNU General Public License at gnu.org/licenses/gpl.html.
"""

import optparse
import os
import copy
import random
import sys
import string
import time

# the following definitions can be accessed in the simulator

current_thread = None


def noop(*args):
    """A handy function that does nothing."""


def balk():
    """Jumps to the top of the column."""
    current_thread.balk()


class Semaphore:
    """Represents a semaphore in the simulator.

    Maintains a random queue.
    """

    def __init__(self, n=0):
        self.n = n
        self.queue = []

    def __str__(self):
        return str(self.n)

    def wait(self):
        self.n -= 1
        if self.n < 0:
            self.block()
        return self.n

    def block(self):
        thread = current_thread
        thread.enqueue()
        self.queue.append(thread)

    def signal(self, n=1):
        for i in range(n):
            self.n += 1
            if self.queue:
                self.unblock()

    def unblock(self):
        """Chooses a random thread and unblocks it."""
        thread = random.choice(self.queue)
        self.queue.remove(thread)
        thread.dequeue()
        thread.next_loop()


class FifoSemaphore(Semaphore):
    """Semaphore that implements a FIFO queue."""

    def unblock(self):
        """Chooses the first thread and unblocks it."""
        thread = self.queue.pop(0)
        thread.dequeue()
        thread.next_loop()


class Lightswitch:
    """Encapsulates the lightswitch pattern."""

    def __init__(self):
        self.counter = 0
        self.mutex = Semaphore(1)

    def lock(self, semaphore):
        self.mutex.wait()
        self.counter += 1
        if self.counter == 1:
            semaphore.wait()
        self.mutex.signal()

    def unlock(self, semaphore):
        self.mutex.wait()
        self.counter -= 1
        if self.counter == 0:
            semaphore.signal()
        self.mutex.signal()


def pid():
    """Gets the ID of the current thread."""
    return current_thread.name


def num_threads():
    """Gets the number of threads."""
    sync = current_thread.column.p
    return len(sync.threads)


# make globals and locals for the simulator

sim_globals = copy.copy(globals())
sim_locals = dict()

# anything defined after this point is not available inside the simulator


# get the version of Python
v = sys.version.split()[0].split(".")
major = int(v[0])

if major == 2:
    all_thread_names = string.uppercase + string.lowercase
else:
    all_thread_names = string.ascii_uppercase + string.ascii_lowercase


class Sync:
    """Represents the thread simulator."""

    def __init__(self, args=[""]):
        self.parse_args(args)

        self.locals = sim_locals
        self.globals = sim_globals

        self.views = {}
        self.w = self
        self.threads = []
        self.running = False
        self.delay = 0.2
        self.setup()
        self.run_init()

    def parse_args(self, args):
        parser = optparse.OptionParser()
        (self.options, args) = parser.parse_args(args)

        if args:
            self.filename = args[0]
        else:
            self.filename = ""

    def get_threads(self):
        return self.threads

    def set_global(self, **kwds):
        self.globals.update(kwds)

    def get_global(self, attr):
        return self.globals[attr]

    def setup(self):
        """Reads in the code."""
        if self.filename:
            self.read_file(self.filename)

    def register(self, thread):
        """Adds a new thread."""
        print(f"Registering thread {thread.name}")
        self.threads.append(thread)

    def unregister(self, thread):
        """Removes a thread."""
        print(f"Removing thread {thread.name}")
        self.threads.remove(thread)

    def run(self):
        """Runs the simulator with round-robin scheduling."""
        self.run_helper(self.step)

    def random_run(self):
        """Runs the simulator with random scheduling."""
        self.run_helper(self.random_step)

    def run_helper(self, step=None):
        """Runs the threads until someone clears self.running."""
        self.running = True
        while self.running:
            step()
            time.sleep(self.delay)

    def step(self):
        """Advances all the threads in order"""
        for thread in self.threads:
            thread.step_loop()

    def random_step(self):
        """Advances one random thread."""
        threads = [thread for thread in self.threads if not thread.queued]
        if not threads:
            print("There are currently no threads that can run.")
            return
        thread = random.choice(threads)
        thread.step_loop()

    def stop(self):
        """Stops running."""
        self.running = False

    def read_file(self, filename):
        """Read a file that contains code for the simulator to execute.

        Lines that start with ## do not appear
        in the display.

        A line that starts with "## thread" indicates the beginning of
        a new column of code.

        Returns a list of blocks where each block is a list of lines.
        """

        def is_new_thread(line):
            if line[0:2] != "##":
                return False

            words = line.strip("#").split()
            word = words[0].lower()
            if word == "thread":
                return " ".join(words[1:]) or len(self.threads)
            return False

        block = []
        name = "init"

        fp = open(filename)
        for line in fp:
            line = line.rstrip()

            new_thread = is_new_thread(line)
            if new_thread:
                self.register(Thread(self, block, name))
                block = []
                name = new_thread
            else:
                block.append(line)

        self.register(Thread(self, block, name))
        fp.close()

    def run_init(self):
        """Runs the initialization code in the top column."""

        print("running init")

        thread = self.threads[0]
        thread.run()

        self.unregister(thread)


def subtract(d1, d2):
    """Subtracts two dictionaries.

    Returns a new dictionary containing all the keys from
    d1 that are not in d2.
    """
    d = {}
    for key in d1:
        if key not in d2:
            d[key] = d1[key]
    return d


def diff_dict(d1, d2):
    """Diffs two dictionaries.

    Returns two dictionaries: the first contains all the keys
    from d1 that are not in d2; the second contains all the keys
    that are in both dictionaries, but which have different values.
    """
    d = {}
    c = {}
    for key in d1:
        if key not in d2:
            d[key] = d1[key]
        elif d1[key] is not d2[key]:
            c[key] = d1[key]
    return d, c


def trim_block(block):
    """Removes comments from the beginning and empty lines from the end."""
    if block and block[0].startswith("#"):
        block.pop(0)

    while block and not block[-1].strip():
        block.pop(-1)


class Namespace:
    """Used to store thread-local variables.

    Inside the simulator, self refers to the thread's namespace.
    """


class Thread:
    """Represents simulated threads."""

    def __init__(self, sync, instructions, name):
        self.sync = sync
        self.instructions = instructions
        self.name = name
        self.namespace = Namespace()
        self.flag_map = {}
        self.while_stack = []
        self.start()

    def __str__(self):
        return f"<{self.name} {self.iptr}>"

    def enqueue(self):
        """Puts this thread into queue."""
        self.queued = True

    def dequeue(self):
        """Removes this thread from queue."""
        self.queued = False

    def jump_to(self, row):
        """Removes this thread from its current row and moves it to row."""
        self.iptr = row

    def balk(self):
        self.iptr = 0

    def start(self):
        """Moves this thread to the top of the column."""
        self.queued = False
        self.iptr = 0

    def next_loop(self):
        """Moves to the next row, looping to the top if necessary."""
        self.next_row()
        if self.iptr >= len(self.instructions):
            self.start()

    def next_row(self):
        """Moves this thread to the next row in the column."""
        if self.queued:
            return

        self.iptr = self.iptr + 1

    def skip_body(self):
        """Skips the body of a conditional."""
        # get the current line
        # get the next line
        # compute the change in indent
        # find the outdent
        source = self.instructions[self.iptr]
        head_indent = self.count_spaces(source)

        self.next_row()
        source = self.instructions[self.iptr]
        body_indent = self.count_spaces(source)

        indent = body_indent - head_indent

        if indent <= 0:
            raise SyntaxError("Body of compound statement must be indented.")

        while True:
            self.next_row()
            if self.iptr >= len(self.instructions):
                break

            source = self.instructions[self.iptr]
            line_indent = self.count_spaces(source)
            if line_indent <= head_indent:
                break

    def count_spaces(self, source):
        """Returns the number of leading spaces after expanding tabs."""
        s = source.expandtabs(4)
        t = s.lstrip(" ")
        return len(s) - len(t)

    def step(self, event=None):
        """Executes the current line of code, then moves to the next row.

        The current limitation of this simulator is that each row
        has to contain a complete Python statement.  Also, each line
        of code is executed atomically.

        Args:
            event: unused, provided so that this method can be used
                   as a binding callback

        Returns:
            line of code that executed or None
        """
        if self.queued:
            return None

        if self.iptr >= len(self.instructions):
            return None

        self.check_end_while()
        source = self.instructions[self.iptr]
        print(self, source)

        before = copy.copy(self.sync.locals)

        flag = self.exec_line(source, self.sync)

        # see if any variables were defined or changed
        after = self.sync.locals
        defined, changed = diff_dict(after, before)

        # either skip to the next line or to the end of a false conditional
        if flag:
            self.next_row()
        else:
            self.skip_body()

        return source

    def exec_line(self, source, sync):
        """Runs a line of source code in the context of the given Sync.

        Args:
            source: source code from a Row
            sync: Sync object

        Returns:
            if the line is an if statement, returns the result of
            evaluating the condition
        """
        global current_thread
        current_thread = self

        sync.globals["self"] = self.namespace

        try:
            s = source.strip()
            code = compile(s, "<user-provided code>", "exec")
            exec(code, sync.globals, sync.locals)
            return True
        except SyntaxError as error:
            # check whether it's a conditional statement
            keyword = s.split()[0]
            if keyword in ["if", "else:", "while"]:
                flag = self.handle_conditional(keyword, source, sync)
                return flag
            else:
                raise error

    def handle_conditional(self, keyword, source, sync):
        """Evaluates the condition part of an if statement.

        Args:
            keyword: if, else or while
            source: source code from a Row
            sync: Sync object

        Returns:
            if the line is an if statement, returns the result of
            evaluating the condition; otherwise raises a SyntaxError
        """
        s = source.strip()
        if not s.endswith(":"):
            raise SyntaxError("Header must end with :")

        if keyword in ["if"]:
            # evaluate the condition
            n = len(keyword)
            condition = s[n:-1].strip()
            flag = eval(condition, sync.globals, sync.locals)

            # store the flag
            indent = self.count_spaces(source)
            self.flag_map[indent] = flag

            return flag

        elif keyword in ["while"]:
            # evaluate the condition
            n = len(keyword)
            condition = s[n:-1].strip()
            flag = eval(condition, sync.globals, sync.locals)

            if flag:
                indent = self.count_spaces(source)
                self.while_stack.append((indent, self.iptr))

            return flag

        else:
            assert keyword == "else:"
            # see whether the condition was true
            indent = self.count_spaces(source)
            try:
                flag = self.flag_map[indent]
                return not flag
            except KeyError:
                raise SyntaxError("else does not match if")

    def check_end_while(self):
        """Check if we are at the end of a while loop.

        If so, jump to the top.
        """
        if not self.while_stack:
            return

        indent, row = self.while_stack[-1]

        source = self.instructions[self.iptr]
        if self.count_spaces(source) <= indent:
            self.while_stack.pop()
            self.jump_to(row)

    def step_loop(self, event=None):
        self.step()
        if self.iptr >= len(self.instructions):
            self.start()

    def run(self):
        while True:
            self.step()
            if self.iptr >= len(self.instructions):
                break


def main():
    sync = Sync(sys.argv[1:])
    sync.random_run()


if __name__ == "__main__":
    main()
